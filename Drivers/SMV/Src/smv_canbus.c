#include "../Inc/smv_canbus.h"
#include <string.h>
/*
IMPORTANT:
This file is a just a copy and paste of the functions that were set up in the large main file; The library has not been tested in this form yet
The main file has enums and char arrays that also need to be included in their own file (we can reuse the files from the old library)
We need to confirm that we have all the includes we need
*/

void Error_Handler(void); // must be provided by user

typedef union {
	double num;
	uint8_t arr[8];
} DoubleCaster;

const char* devices[] = {
    "Bear_1",
    "UI",
    "HS1",
    "HS2",
    "HS3",
    "HS4",
    "FC",
    "Joule_H",
    "Joule_L",
    "Safety",
    "DAQ_Board",
};


const char* motorMessage[] = {
    "Hall_velocity",
    "Torque_motor",
    "Current",
    "Board_Temp",
    "Motor_Temp",
};

const char* UIMessage[] = {
    "Blink_Left",
    "Blink_Right",
    "Reverse",
    "Headlights",
    "Wipers",
    "Hazard",
    "Button",
    "Switch",
    "Motor",
    "Horn",
    "DAQ_Button",
};

const char* HSMessage[] = {
    "Gyro_x",
    "Gyro_y",
    "Gyro_z",
    "Accel_x",
    "Accel_y",
    "Accel_z",
    "Pressure",
    "Torque_HS",
};

const char* FrontcenterMessage[] = {
    "Gas",
    "Brake",
};

const char* JoulemeterMessage[] = {
    "Power",
};

const char* DAQMessage[] = {
    "Longitude",
    "Latitude",
    "Speed"
};

const char* readHardware(int first) {
    return devices[first];
}

const char* readDataType(int first, int last)
{
    switch (first)
    {
    case 0:
        return motorMessage[last];
        break;
    case 1:
        return UIMessage[last];
        break;
    case 2:
    case 3:
    case 4:
    case 5:
        return HSMessage[last];
        break;
    case 6:
        return FrontcenterMessage[last];
        break;
    case 7:
    case 8:
        return JoulemeterMessage[last];
        break;
    case 9:
        return "Safety";
        break;
    case 10:
        return DAQMessage[last];
        break;
    }
    return "";
}

/*
Purpose:
- Initialize can object with our tested can settings
- Set initial open filter (0x0000) --> gets overwritten if programmer uses AddFilter function
- Initialize filter_bank to 0

Programmer's POV:
- Enable CAN1, initialize CAN pins, enable interrupts, and set clock

Reasons for limiting abstraction (programmer will have to set up ioc in the beginning):
- stm32f4xx_hal_conf has a vital line: #define HAL_CAN_MODULE_ENABLED
    - this file is generated by CubeMX and gets called before the library does; the programmer will be expected to define this macro, which is not that intuitive
- stm32f4xx_hal_msp sets up the pins
    - if the library does this without the programmer interacting with the ioc, the ioc UI will never show the CAN pins, which could be akward
*/
static void CAN_QuickSetup(CANBUS *can, int hardware, CAN_HandleTypeDef *can_obj){
	can->hcan = can_obj;

	for (int i = 0; i < 8; i++){
		can->RxDataFIFO0 [i] = 0;
	}

	can->data = 0;


	can->device_id = hardware;
	can->filter_bank = 0;

	can->hcan->Instance = CAN1;
	can->hcan->Init.Prescaler = 6;
	can->hcan->Init.Mode = CAN_MODE_NORMAL;
	can->hcan->Init.SyncJumpWidth = CAN_SJW_1TQ;
	can->hcan->Init.TimeSeg1 = CAN_BS1_9TQ;
	can->hcan->Init.TimeSeg2 = CAN_BS2_2TQ;
	can->hcan->Init.TimeTriggeredMode = DISABLE;
	can->hcan->Init.AutoBusOff = ENABLE;
	can->hcan->Init.AutoWakeUp = DISABLE;
	can->hcan->Init.AutoRetransmission = ENABLE;
	can->hcan->Init.ReceiveFifoLocked = DISABLE;
	can->hcan->Init.TransmitFifoPriority = DISABLE;

	__HAL_RCC_CAN1_CLK_ENABLE();

	if (HAL_CAN_Init(can_obj) != HAL_OK)
	{
		Error_Handler();
	}

	can->sFilterConfig.SlaveStartFilterBank = 14;           /* Slave start bank Set only once. */

	can->sFilterConfig.FilterBank = 0;                      /* Select the filter number 0 */
	can->sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;  /* Using ID mask mode .. */
	can->sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT; /* .. in 32-bit scale */
	can->sFilterConfig.FilterIdHigh = 0x0000;
	can->sFilterConfig.FilterIdLow = 0x0000;                /* The filter is set to receive only the Standard ID frames */
	can->sFilterConfig.FilterMaskIdHigh = 0x0000;           /* Accept all the IDs .. except the Extended frames */
	can->sFilterConfig.FilterMaskIdLow = 0x0000;            /* The filter is set to check only on the ID format */
	can->sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0; /* All the messages accepted by this filter will be received on FIFO1 */
	can->sFilterConfig.FilterActivation = ENABLE;           /* Enable the filter number 0 */


	if (HAL_CAN_ConfigFilter(can_obj, &(can->sFilterConfig)) != HAL_OK)
	{
	   /* Filter configuration Error */
	   Error_Handler();
	}
}

/*
Purpose:
- Separate starting and initializing CAN. This way, the programmer can set up filters after initializing.
- Initialize TxHeader (except StdId) --> this will probably be moved to QuickSetup at some point

The following HAL functions will be used:
- HAL_CAN_Start(&hcan)
- HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO1_MSG_PENDING) \
*/
static void CAN_Run(CANBUS *can){
	if (HAL_CAN_Start(can->hcan) != HAL_OK)
	{
		/* Start Error */
		Error_Handler();
	}

	if (HAL_CAN_ActivateNotification(can->hcan, CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_RX_FIFO1_MSG_PENDING) != HAL_OK)
	{
		 /* Notification Error */
		 Error_Handler();
	}

    can->TxHeader.RTR = CAN_RTR_DATA;         /* The frames that will be sent are Data */
    can->TxHeader.DLC = 8;                    /* The frames will contain 8 data bytes */
    can->TxHeader.IDE = CAN_ID_STD;

    can->TxHeader.TransmitGlobalTime = DISABLE;

}

/*
Purpose:
- Cast double message to byte array of 8 bytes (use DoubleCaster union)
- Form TxHeader.StdId from the device_id and data_type
- Check mailbox availability and send message
*/
static void CAN_Send(CANBUS *can, double message, uint8_t data_type){
	can->TxHeader.StdId = ((can->device_id & 0x0F) << 7) + data_type;

	DoubleCaster c;
	c.num = message;

	for (int j = 0; j < 8; j++){
		can->TxData[j] = c.arr[j];
	}

	/* It's mandatory to look for a free Tx mail box */
	while(HAL_CAN_GetTxMailboxesFreeLevel(can->hcan) == 0) {} /* Wait till a Tx mailbox is free. Using while loop instead of HAL_Delay() */

	if (HAL_CAN_AddTxMessage(can->hcan, &(can->TxHeader), can->TxData, &(can->TxMailbox)) != HAL_OK) /* Send the CAN frame */
	{
		/* Transmission request Error */
		Error_Handler();
	}


}

/*
Purpose: return the data double assigned in the CAN interrupt
*/
static double CAN_GetData(CANBUS *can){
	return can->data;
}

/*
Purpose: return the dataType string assigned in the CAN interrupt
*/
static char* CAN_GetDataType(CANBUS *can){
	return can->dataType;
}

/*
Purpose: return the hardware string assigned in the CAN interrupt
*/
static char* CAN_GetHardware(CANBUS *can){
	return can->hardware;
}

void CAN_Interrupt_Helper(CANBUS *can){
	DoubleCaster c;
	for (int i = 0; i<8; i++){
		c.arr[i] = can->RxDataFIFO0[i];
	}
	can->data = c.num;

	//assign hardware array
	uint8_t hardware_id = ((can->RxHeaderFIFO0.StdId)>>7)& 0x0F;
	const char* hardware_string = devices[hardware_id];
	memcpy(can->hardware, hardware_string , strlen(hardware_string)+1);


	//assign dataType array
	uint8_t dataType_id = (can->RxHeaderFIFO0.StdId)&0x0F;
	const char* dataType_string = readDataType(hardware_id, dataType_id);
	memcpy(can->dataType, dataType_string, strlen(dataType_string)+1);
}

/*
Purpose:
- Receive only data from a certain device

Method:
- Set filter to 0b [device_id: 4 bits] 000 0000
- Set mask to 0b 1111 111 0000 --> compare only the first 7 bits
- Increment filter_bank every call (must be between 0 and 13 to operate)

*/
static void CAN_AddFilterDevice(CANBUS *can, int device_id){
    can->sFilterConfig.FilterBank = can->filter_bank;
	can->sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
	can->sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
	can->sFilterConfig.FilterIdHigh = ((device_id & 0x0F) << 7)<<5;
	can->sFilterConfig.FilterIdLow = 0x0000;
	can->sFilterConfig.FilterMaskIdHigh = 0xF000;
	can->sFilterConfig.FilterMaskIdLow = 0x0000;
	can->sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
	can->sFilterConfig.FilterActivation = ENABLE;

	if (HAL_CAN_ConfigFilter(can->hcan, &(can->sFilterConfig)) != HAL_OK)
	{
	   /* Filter configuration Error */
	   Error_Handler();
	}

	can->filter_bank++;
}

/*
Purpose:
- Receive only the device+datatype that it needs to reduce the frequency of FIFO interrupts

Method:
- Set filter to encoded ID: [device_id: 4 bits] 000 [data_type: 4 bits]
- Set mask to 0b 1111 1111 1111
- Increment filter_bank every call (must be between 0 and 13 to operate)

*/
static void CAN_AddFilterDeviceData(CANBUS *can, int device_id, int data_type){
    can->sFilterConfig.FilterBank = can->filter_bank;
	can->sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
	can->sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
	can->sFilterConfig.FilterIdHigh = (((device_id & 0x0F) << 7) + data_type)<<5;
	can->sFilterConfig.FilterIdLow = 0x0000;
	can->sFilterConfig.FilterMaskIdHigh = 0b1111000111100000;
	can->sFilterConfig.FilterMaskIdLow = 0x0000;
	can->sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
	can->sFilterConfig.FilterActivation = ENABLE;

	if (HAL_CAN_ConfigFilter(can->hcan, &(can->sFilterConfig)) != HAL_OK)
	{
	   /* Filter configuration Error */
	   Error_Handler();
	}

	can->filter_bank++;
}


CANBUS CAN_new(void) {
	CANBUS can;
	can.init = CAN_QuickSetup;
	can.begin = CAN_Run;
	can.getData = CAN_GetData;
	can.getDataType = CAN_GetDataType;
	can.getHardware = CAN_GetHardware;
	can.addFilterDevice = CAN_AddFilterDevice;
	can.addFilterDeviceData = CAN_AddFilterDeviceData;
	can.send = CAN_Send;
	return can;
}

